import { EventEmitter } from "eventemitter3";
interface UtilSupportsObj {
    browser: boolean;
    webRTC: boolean;
    audioVideo: boolean;
    data: boolean;
    binaryBlob: boolean;
    reliable: boolean;
}
declare class Util {
    noop(): void;
    readonly CLOUD_HOST = "0.peerjs.com";
    readonly CLOUD_PORT = 443;
    readonly chunkedBrowsers: {
        Chrome: number;
        chrome: number;
    };
    readonly chunkedMTU = 16300;
    readonly defaultConfig: {
        iceServers: ({
            urls: string;
            username?: undefined;
            credential?: undefined;
        } | {
            urls: string[];
            username: string;
            credential: string;
        })[];
        sdpSemantics: string;
    };
    readonly browser: string;
    readonly browserVersion: number;
    readonly supports: UtilSupportsObj;
    validateId(id: string): boolean;
    pack: any;
    unpack: any;
    chunk(blob: Blob): {
        __peerData: number;
        n: number;
        total: number;
        data: Blob;
    }[];
    blobToArrayBuffer(blob: Blob, cb: (arg: ArrayBuffer | null) => void): FileReader;
    binaryStringToArrayBuffer(binary: string): ArrayBuffer | SharedArrayBuffer;
    randomToken(): string;
    isSecure(): boolean;
}
export const util: Util;
enum LogLevel {
    Disabled = 0,
    Errors = 1,
    Warnings = 2,
    All = 3
}
enum ConnectionType {
    Data = "data",
    Media = "media"
}
enum PeerErrorType {
    BrowserIncompatible = "browser-incompatible",
    Disconnected = "disconnected",
    InvalidID = "invalid-id",
    InvalidKey = "invalid-key",
    Network = "network",
    PeerUnavailable = "peer-unavailable",
    SslUnavailable = "ssl-unavailable",
    ServerError = "server-error",
    SocketError = "socket-error",
    SocketClosed = "socket-closed",
    UnavailableID = "unavailable-id",
    WebRTC = "webrtc"
}
enum SerializationType {
    Binary = "binary",
    BinaryUTF8 = "binary-utf8",
    JSON = "json"
}
enum ServerMessageType {
    Heartbeat = "HEARTBEAT",
    Candidate = "CANDIDATE",
    Offer = "OFFER",
    Answer = "ANSWER",
    Open = "OPEN",
    Error = "ERROR",
    IdTaken = "ID-TAKEN",
    InvalidKey = "INVALID-KEY",
    Leave = "LEAVE",
    Expire = "EXPIRE"
}
/**
 * An abstraction on top of WebSockets to provide fastest
 * possible connection for peers.
 */
declare class Socket extends EventEmitter {
    constructor(secure: any, host: string, port: number, path: string, key: string, pingInterval?: number);
    start(id: string, token: string): void;
    /** Exposed send for DC & Peer. */
    send(data: any): void;
    close(): void;
}
declare class ServerMessage {
    type: ServerMessageType;
    payload: any;
    src: string;
}
declare abstract class BaseConnection extends EventEmitter {
    readonly peer: string;
    provider: Peer;
    readonly options: any;
    protected _open: boolean;
    readonly metadata: any;
    connectionId: string;
    peerConnection: RTCPeerConnection;
    abstract get type(): ConnectionType;
    get open(): boolean;
    constructor(peer: string, provider: Peer, options: any);
    abstract close(): void;
    abstract handleMessage(message: ServerMessage): void;
}
/**
 * Wraps a DataChannel between two Peers.
 */
export class DataConnection extends BaseConnection implements DataConnection {
    readonly label: string;
    readonly serialization: SerializationType;
    readonly reliable: boolean;
    stringify: (data: any) => string;
    parse: (data: string) => any;
    get type(): ConnectionType;
    get dataChannel(): RTCDataChannel;
    get bufferSize(): number;
    constructor(peerId: string, provider: Peer, options: any);
    /** Called by the Negotiator when the DataChannel is ready. */
    initialize(dc: RTCDataChannel): void;
    /**
     * Exposed functionality for users.
     */
    /** Allows user to close connection. */
    close(): void;
    /** Allows user to send data. */
    send(data: any, chunked?: boolean): void;
    handleMessage(message: ServerMessage): void;
}
interface AnswerOption {
    sdpTransform?: Function;
}
interface PeerJSOption {
    key?: string;
    host?: string;
    port?: number;
    path?: string;
    secure?: boolean;
    token?: string;
    config?: RTCConfiguration;
    debug?: number;
}
interface PeerConnectOption {
    label?: string;
    metadata?: any;
    serialization?: string;
    reliable?: boolean;
}
/**
 * Wraps the streaming interface between two Peers.
 */
export class MediaConnection extends BaseConnection {
    get type(): ConnectionType;
    get localStream(): MediaStream;
    get remoteStream(): MediaStream;
    constructor(peerId: string, provider: Peer, options: any);
    addStream(remoteStream: any): void;
    handleMessage(message: ServerMessage): void;
    answer(stream: MediaStream, options?: AnswerOption): void;
    /**
     * Exposed functionality for users.
     */
    /** Allows user to close connection. */
    close(): void;
}
declare class PeerOptions implements PeerJSOption {
    debug?: LogLevel;
    host?: string;
    port?: number;
    path?: string;
    key?: string;
    token?: string;
    config?: any;
    secure?: boolean;
    pingInterval?: number;
    logFunction?: (logLevel: LogLevel, ...rest: any[]) => void;
}
/**
 * A peer who can initiate connections with other peers.
 */
export class Peer extends EventEmitter {
    get id(): string;
    get options(): PeerOptions;
    get open(): boolean;
    get socket(): Socket;
    /**
     * @deprecated
     * Return type will change from Object to Map<string,[]>
     */
    get connections(): Object;
    get destroyed(): boolean;
    get disconnected(): boolean;
    constructor(id?: string | PeerOptions, options?: PeerOptions);
    /** Retrieve messages from lost message store */
    _getMessages(connectionId: string): ServerMessage[];
    /**
     * Returns a DataConnection to the specified peer. See documentation for a
     * complete list of options.
     */
    connect(peer: string, options?: PeerConnectOption): DataConnection;
    /**
     * Returns a MediaConnection to the specified peer. See documentation for a
     * complete list of options.
     */
    call(peer: string, stream: MediaStream, options?: any): MediaConnection;
    _removeConnection(connection: BaseConnection): void;
    /** Retrieve a data/media connection for this peer. */
    getConnection(peerId: string, connectionId: string): null | BaseConnection;
    /** Emits a typed error message. */
    emitError(type: PeerErrorType, err: string | Error): void;
    /**
     * Destroys the Peer: closes all active connections as well as the connection
     *  to the server.
     * Warning: The peer can no longer create or accept connections after being
     *  destroyed.
     */
    destroy(): void;
    /**
     * Disconnects the Peer's connection to the PeerServer. Does not close any
     *  active connections.
     * Warning: The peer can no longer create or accept connections after being
     *  disconnected. It also cannot reconnect to the server.
     */
    disconnect(): void;
    /** Attempts to reconnect with the same ID. */
    reconnect(): void;
    /**
     * Get a list of available peer IDs. If you're running your own server, you'll
     * want to set allow_discovery: true in the PeerServer options. If you're using
     * the cloud server, email team@peerjs.com to get the functionality enabled for
     * your key.
     */
    listAllPeers(cb?: (_: any[]) => void): void;
}
export default Peer;

//# sourceMappingURL=types.d.ts.map
